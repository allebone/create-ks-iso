#!/usr/bin/env bash

# Reference:  How to create a modified Red Hat Enterprise Linux ISO with kickstart file 
#             or modified installation media? (https://access.redhat.com/solutions/60959)

# Required packages: isomd5sum, syslinux, genisoimage

###############
## Variables ##
###############

# Source Media Location
ISOSRCDIR="./isosrc" 

# Exit if ISO source location does not exist
# Note: We don't create this automatically to avoid potentially clobbering a large ISO store
if [ ! -d "$ISOSRCDIR" ]
  then echo "ISO source directory not found, please correct. Exiting."
  exit
fi

# ISO Result Location
ISORESULTDIR="./result"

# Create ISO Result Location if it does not exist
mkdir -p $ISORESULTDIR

# OEM Source Media File Name
OEMSRCISO="CentOS-Stream-9-latest-x86_64-dvd1.iso"

# File Name for newly-created final ISO file
NEWISONAME="Random_Creds-CentOS-Stream-9-latest-x86_64-dvd1.iso"

# Source kickstart config file, locate in $SRCDIR
KSCFGSRCFILE="ks.cfg"

# Do not change this, Red Hat internals look for this specific name
KSCFGDESTFILENAME="ks.cfg"

# ISO Volume Name must match or boot will fail
OEMSRCISOVOLNAME=$(blkid -o value $ISOSRCDIR/$OEMSRCISO | sed -n 3p)

# Temporary mount point for OEM Source Media
ISOTMPMNT="./mnt/iso"

# Create temporary mount point for OEM Source Media if it does not exist
mkdir -p $ISOTMPMNT

SCRATCHISONAME="NEWISO.iso"

# Source files for implantation into new ISO (ks.cfg, etc.)
# This needs to be an absolute path, not a relative path.
SRCDIR="${PWD}"

# Ensure these directories are mounted where 4GB+ files are allowed, /tmp may not support this
SCRATCHDIR="./tmp"
WORKDIRNAME="iso-workdir"
WORKDIR=$SCRATCHDIR/$WORKDIRNAME
# Create scratch space directory
mkdir -p $WORKDIR

##################
## Main Section ##
##################

# Check for required root privileges
if [ "$EUID" -ne 0 ]
  then echo "This script requires root privileges for the \"mount\" command. Please run with sudo or su."
  exit
fi

# Remove old ssh keys
rm -f svc.ansible.id_rsa svc.ansible.id_rsa.pub

##############################################
# Generate Random Passwords and new ssh keys #
##############################################

# Generate a random password of 16 characters using python
password=$(python3 -c 'import random; import string; print("".join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(16)))')

# Write password to file
echo "$password" > password.txt

# Encrypt the password using python with a FIPS-compliant cypher
encrypted_password=$(python3 -c 'import crypt,getpass; print(crypt.crypt("$password", crypt.mksalt(crypt.METHOD_SHA512)))')

# Generate grub2 bootloader password, unfortunately the grub2-mkpasswd-pbkdf2
# command is interactive-only, so we have to emulate the keypresses:
grub2_password=$(echo -e "$password\n$password" | grub2-mkpasswd-pbkdf2 | awk '/grub.pbkdf/{print$NF}')

# Create ssh key pair
ssh-keygen -t ecdsa-sha2-nistp521 -b 521 -N "" -f ./svc.ansible.id_rsa -q -C "kickstart-generated bootstrapping key"
ssh_pub_key=$(<svc.ansible.id_rsa.pub)

# Copy ks.cfg from template file
cp ks-template.cfg ks.cfg

# Append required lines to kickstart file (ks.cfg)
cat << EOF >> ks.cfg
# Set the system's root password (required)
rootpw --iscrypted $encrypted_password

# Specify how the bootloader should be installed (required)
# This password hash must be generated by: grub2-mkpasswd-pbkdf2
bootloader --append "fips=1" --iscrypted --password=$grub2_password

# user (optional)
#   User Notes:
#     Users in group wheel can sudo and elevate
#     svc.ansible is initial provisioning account using SSH keys
#     alt.admin is "break glass" alternate emergency account
#     alt.admin can login remotely. 
#     Direct root login is only allowed from console.
user --name=svc.ansible --groups=wheel --gecos='Ansible Service Account' --password=$encrypted_password --iscrypted

# sshkey (optional)
# Adds SSH key to the authorized_keys file of the specified user
# sshkey --username=user "ssh_key"
sshkey --username=svc.ansible "$ssh_pub_key"
EOF

# Mount OEM Install Media ISO
mount $ISOSRCDIR/$OEMSRCISO $ISOTMPMNT

# Extract the ISO image into a working directory
shopt -s dotglob
cp -avRf $ISOTMPMNT/* $WORKDIR

# Unmount the OEM ISO
umount $ISOTMPMNT

# Copy ks.cfg into working dir
cp $SRCDIR/$KSCFGSRCFILE $WORKDIR/$KSCFGDESTFILENAME

# Modify isolinux.cfg for FIPS mode and ks boot
sed -i '/rescue/!s/ quiet/ fips=1 inst.ks=cdrom:\/ks.cfg quiet/' $WORKDIR/isolinux/isolinux.cfg
# Modify isolinux.cfg menu title
sed -i 's/menu title Red/menu title STIG Kickstart Install Red/' $WORKDIR/isolinux/isolinux.cfg

# Modify grub.cfg for ks boot
sed -i '/rescue/!s/ quiet/ inst.ks=cdrom:\/ks.cfg quiet/' $WORKDIR/EFI/BOOT/grub.cfg
# Modify grub.cfg menu entries to show STIG compliance
sed -i 's/Install/STIG Install/' $WORKDIR/EFI/BOOT/grub.cfg
sed -i 's/Test/STIG Test/' $WORKDIR/EFI/BOOT/grub.cfg

# Create new ISO  
# Note, the relative pathnames in the arguments to mkisofs are required, as per the man page:
# "The pathname must be relative to the source path..."
# This is why we do the rather ugly "cd" into the working dir below.
cd $WORKDIR || { echo "Unable to change directory, exiting."; exit 1; }
mkisofs -o ../$SCRATCHISONAME -b isolinux/isolinux.bin -J -R -l -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -e images/efiboot.img -no-emul-boot -graft-points -joliet-long -V "$OEMSRCISOVOLNAME" .
cd $SRCDIR || { echo "Unable to change directory, exiting."; exit 1; }

# Build UEFI bootable image
isohybrid --uefi $SCRATCHDIR/$SCRATCHISONAME

# Implant a md5 checksum into the new ISO image
implantisomd5 $SCRATCHDIR/$SCRATCHISONAME

# Move new iso to ISOs dir
mv $SCRATCHDIR/$SCRATCHISONAME $ISORESULTDIR/$NEWISONAME

# Chown new ISO (will be owned by root otherwise)
chown "$SUDO_UID":"$SUDO_GID" $ISORESULTDIR/$NEWISONAME

# Clean up work directory
rm -rf $WORKDIR
